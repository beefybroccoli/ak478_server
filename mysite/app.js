var debug = require('debug')('cecs-478:app');

var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var index = require('./routes/index');
var users = require('./routes/users');

var app = express();

//// Changes from default app.js generated by express-generator

// Added for extra hardening
var helmet = require('helmet');
app.use(helmet());

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

// uncomment after placing your favicon in /public
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));
//commented out in favor of custom logger format
//app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

// Custom Logger Format: Standard Apache combined log output with colored Status messages
logger.format('custom', function developmentFormatLine(tokens, req, res) {

    function headersSent(res) {
        return typeof res.headersSent !== 'boolean'
            ? Boolean(res._header)
            : res.headersSent
    }

    // get the status code if response written
    var status = headersSent(res)
        ? res.statusCode
        : undefined

    // get status color
    var color = status >= 500 ? 31 // red
        : status >= 400 ? 33 // yellow
            : status >= 300 ? 36 // cyan
                : status >= 200 ? 32 // green
                    : 0 // no color

    // get colored function
    var fn = developmentFormatLine[color]

    if (!fn) {
        // compile

	if (req.secure) {
        	fn = developmentFormatLine[color] = logger.compile('\x1b[0m::remote-addr - :remote-user [:date[clf]] ":method :url HTTPS/:http-version" \x1b[' +
			color + 'm:status \x1b[0m :res[content-length] ":referrer" ":user-agent"\x1b[0m')
	} else {
        	fn = developmentFormatLine[color] = logger.compile('\x1b[35m::remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" \x1b[' +
            		color + 'm:status \x1b[35m :res[content-length] ":referrer" ":user-agent"\x1b[0m')
	}
    }

    return fn(tokens, req, res)
})

app.use(logger('custom'));

///// HTTP to HTTPS redirect
///// https://www.tonyerwin.com/2014/09/redirecting-http-to-https-with-nodejs.html
app.use(function (req, res, next) {
        if (req.secure) {
                // request was via https, so do no special handling
                next();
        } else {
                // request was via http, so redirect to https
                res.redirect(308,'https://' + req.headers.host + req.url);
        }
});

/*///////////////////////////////////////////////////////////////////////////////

Authentication Stuff

//////////////////////////////////////////////////////////////////////////////*/

var config = require('./config/database');
var User = require('./models/user');
var passport = require('passport');         // Authentication middleware
var mongoose = require('mongoose');         // Connect to MongoDB
var jwt = require('jwt-simple');            // Simple JWT encoding/decoding

app.use(passport.initialize());

// Use native promises
mongoose.Promise = global.Promise;

// connect to database
mongoose.connect(config.database, { useMongoClient: true });

// pass passport for configuration
require('./config/passport')(passport);

// bundle our routes
var apiRoutes = express.Router();

// create a new user account (POST http://localhost:8080/api/signup)
apiRoutes.post('/signup', function (req, res) {
debug(req); debug(res);
    if (!req.body.name || !req.body.password) {
        // HTTP 400 - Bad Request (client error)
        res.status(400).json({ success: false, msg: 'Please provide a name and password.' });
    } else {
        var newUser = new User({
            name: req.body.name,
            password: req.body.password
        });
        // save the user
        newUser.save(function (err) {
            if (err) {
                // HTTP 400 - Bad Request (client error)
                return res.status(400).json({ success: false, msg: 'Username already exists.' });
            }
            // HTTP 201 - Created
            res.status(201).json({ success: true, msg: 'Successfully created new user.' });
        });
    }
});

apiRoutes.post('/authenticate', function (req, res) {
    User.findOne({ name: req.body.name }, function (err, user) {
        if (err) throw err;
        // If the user is not found, send "401 Unauthorized" and a JSON object with a failure message
        if (!user) {
            res.status(401).header('WWW-Authenticate', 'Bearer').send({ success: false, msg: 'Authentication failed. User not found.' });
        }
        else {
            // If the HTTP POST does not include a "Response" field, issue a challenge
            if (!req.body.response) {
                // salt from the hash of the user's password
                var salt = user.password.substring(0, 29);
                // 16 byte string used to generate a TOTP
                var challenge = require('hi-base32').encode(require('crypto').randomBytes(10));
                // Save the challenge string in the user database
                User.findOneAndUpdate({ name: req.body.name }, { $set: { challenge: challenge } });
                // HTTP 401 - Not Authorized. Send a JSON object with the challenge and the salt
                // 'WWW-Authenticate' header required to comply with RFC-7235
                res.status(401).header('WWW-Authenticate', 'Bearer')
                    .send({
                        success: false,
                        msg: 'No response to challenge',
                        challenge: challenge,
                        salt: salt
                    });
            }
            else {
                // Verify that the response is correct (bcrypt(TOTP + bcrypt(password))
                if (user.verify(req.body.response)) {
                    var payload = {};
                    payload.name = user.name;
                    // Date.now() gives a value in milliseconds. Divide by 1000 to get seconds
                    payload.iat = Math.round(Date.now() / 1000);		// IAT - Issued AT (current time)
                    payload.exp = Math.round(Date.now() / 1000 + 5 * 60);	// EXP - EXPires (5 * 60 second  expiration)
                    var token = jwt.encode(payload, config.secret);		// Encode JWT
                    //	key: config.secret
                    //	algorithm: default (HS256)
                    res.json({ success: true, token: 'JWT ' + token });
                }
                else {
	            // salt from the hash of the user's password
        	    var salt = user.password.substring(0, 29);
               	    // 16 byte string used to generate a TOTP
                    var challenge = require('hi-base32').encode(require('crypto').randomBytes(10));
                    // Save the challenge string in the user database
                    User.findOneAndUpdate({ name: req.body.name }, { $set: { challenge: challenge } });
                    // HTTP 401 - Not Authorized. Send a JSON object with the challenge and the salt
                    // 'WWW-Authenticate' header required to comply with RFC-7235
                    res.status(401).header('WWW-Authenticate', 'Bearer')
                        .send({
                            success: false,
                            msg: 'Incorrect to challenge',
                            challenge: challenge,
                            salt: salt
                        });
                }
            }
        }
    });
});


// route to a restricted info (GET http://localhost:8080/api/restricted)
apiRoutes.get('/restricted', passport.authenticate('jwt', { session: false }), function (req, res) {
    var token = getToken(req.headers);
    if (token) {
        var decoded = jwt.decode(token, config.secret);
        User.findOne({
            name: decoded.name
        }, function (err, user) {
            if (err) throw err;

            if (!user) {
                // HTTP 403 - Forbidden
                return res.status(403).send({ success: false, msg: 'Authentication failed. User not found.' });
            } else {
                res.json({ success: true, msg: 'Welcome to the restricted area ' + user.name + '!' });
            }
        });
    } else {
        // HTTP 403 - Forbidden
        return res.status(403).send({ success: false, msg: 'No token provided.' });
    }
});

getToken = function (headers) {
    if (headers && headers.authorization) {
        var parted = headers.authorization.split(' ');
        if (parted.length === 2) {
            return parted[1];
        } else {
            return null;
        }
    } else {
        return null;
    }
};

// connect the api routes under /api/
app.use('/api', apiRoutes);

/*//////////////////////////////////////////////////////////////////////////////

End Authentication Stuff

//////////////////////////////////////////////////////////////////////////////*/

//// End changes

app.use('/', index);
app.use('/users', users);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;
